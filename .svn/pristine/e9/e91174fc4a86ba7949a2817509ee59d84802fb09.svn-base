import React, { useState, useEffect, useRef } from 'react';

export default function ParkingArea({ parkingCoordsData, oneCamera, src }) {
	const [widthHeight, setWidthHeight] = useState({ width: '', height: '' });
	const canvasRef = useRef(null);

	const width = widthHeight.width ? widthHeight.width : document.body.clientWidth * 0.55;
	const height = widthHeight.height ? widthHeight.height : document.body.clientHeight * 0.61300309;
	const parkingCameraWidth = 1920;
	const parkingCameraHeight = 1080;
	const backgroundColor = 'transparent';

	const setCanvasStyleSize = async () => {
		if (oneCamera) {
			await setWidthHeight({ width: document.body.clientWidth * 0.55, height: document.body.clientHeight * 0.61300309 });
		} else if (!oneCamera) {
			await setWidthHeight({ width: 739.2, height: 415.8 });
		} else if (oneCamera === undefined) {
			await setWidthHeight({ width: document.body.clientWidth * 0.55, height: document.body.clientHeight * 0.61300309 });
		}
	}

	useEffect(() => {
		console.log(document.body.clientWidth)
		async function drawParkingBox() {
			const canvas = canvasRef.current;
			const ctx = canvas.getContext("2d");
			if (parkingCoordsData && widthHeight.width !== '' && widthHeight.height !== '') {
				ctx.clearRect(0, 0, width, height);
				parkingCoordsData.map((coord) => {
					ctx.beginPath();
					ctx.moveTo(coord.x1 / parkingCameraWidth * widthHeight.width, coord.y1 / parkingCameraHeight * widthHeight.height);
					ctx.lineTo(coord.x2 / parkingCameraWidth * widthHeight.width, coord.y2 / parkingCameraHeight * widthHeight.height);
					ctx.lineTo(coord.x4 / parkingCameraWidth * widthHeight.width, coord.y4 / parkingCameraHeight * widthHeight.height);
					ctx.lineTo(coord.x3 / parkingCameraWidth * widthHeight.width, coord.y3 / parkingCameraHeight * widthHeight.height);
					ctx.lineTo(coord.x1 / parkingCameraWidth * widthHeight.width, coord.y1 / parkingCameraHeight * widthHeight.height)

					ctx.fillStyle = coord.occupancy === "1" && (coord.type === null || coord.type === undefined) ? 'hsla(120, 100%, 25%, 0.3)' :
						coord.occupancy === "1" && coord.type === 0 ? 'hsla(48, 100%, 60%, 0.3)' : // 민원인 
							coord.occupancy === "1" && coord.type === 1 ? 'hsla(50, 100%, 50%, 0.3)' : // 경차
								coord.occupancy === "1" && coord.type === 2 ? 'hsla(240, 100%, 50%, 0.3)' : // 장애인
									coord.occupancy === "1" && coord.type === 3 ? 'hsla(188, 100%, 50%, 0.3)' :  // 전기차
										coord.occupancy === "1" && coord.type === 4 ? 'hsla(0, 100%, 50%, 0.5)' :  // 비주차 구역
											coord.occupancy === "0" ? 'transparent' : ''
					ctx.fill();
					ctx.stroke();

					ctx.fillStyle = 'black';
					ctx.font = "bold 15px Arial";
					ctx.fillText(coord.index_number, coord.x1 / parkingCameraWidth * widthHeight.width + ((coord.x2 / parkingCameraWidth * widthHeight.width - coord.x1 / parkingCameraWidth * widthHeight.width) / 2), coord.y1 / parkingCameraHeight * widthHeight.height + ((coord.y2 / parkingCameraHeight * widthHeight.height - coord.y1 / parkingCameraHeight * widthHeight.height) / 2));
					ctx.stroke();
				})
			}
		}
		src !== '' && drawParkingBox();
	}, [parkingCoordsData, widthHeight, src]);

	useEffect(() => {
		setCanvasStyleSize();
	}, [oneCamera]);


	return (
		<>
			<canvas ref={canvasRef} width={width} height={height} style={{ width, height, backgroundColor }} />
		</>
	)
}